/* Options:
Date: 2025-11-02 18:59:14
Version: 8.91
Tip: To override a DTO option, remove "//" prefix before updating
BaseUrl: https://localhost:5001

//GlobalNamespace: 
//MakePropertiesOptional: False
//AddServiceStackTypes: True
//AddResponseStatus: False
//AddImplicitVersion: 
//AddDescriptionAsComments: True
//IncludeTypes: 
//ExcludeTypes: 
//DefaultImports: encoding/json,time
*/

package dtos

import (
    "encoding/json"
    "time"
)


// @DataContract
type AiContent struct {
    /** @description The type of the content part. */
    // @DataMember(Name="type")
    type string `json:"type"`
}

/** @description The tool calls generated by the model, such as function calls. */
// @DataContract
type ToolCall struct {
    /** @description The ID of the tool call. */
    // @DataMember(Name="id")
    id string `json:"id"`
    /** @description The type of the tool. Currently, only `function` is supported. */
    // @DataMember(Name="type")
    type string `json:"type"`
    /** @description The function that the model called. */
    // @DataMember(Name="function")
    function string `json:"function"`
}

/** @description A list of messages comprising the conversation so far. */
// @DataContract
type AiMessage struct {
    /** @description The contents of the message. */
    // @DataMember(Name="content")
    content []AiContent `json:"content,omitempty"`
    /** @description The role of the author of this message. Valid values are `system`, `user`, `assistant` and `tool`. */
    // @DataMember(Name="role")
    role string `json:"role"`
    /** @description An optional name for the participant. Provides the model information to differentiate between participants of the same role. */
    // @DataMember(Name="name")
    name *string `json:"name,omitempty"`
    /** @description The tool calls generated by the model, such as function calls. */
    // @DataMember(Name="tool_calls")
    tool_calls []ToolCall `json:"tool_calls,omitempty"`
    /** @description Tool call that this message is responding to. */
    // @DataMember(Name="tool_call_id")
    tool_call_id *string `json:"tool_call_id,omitempty"`
}

/** @description Parameters for audio output. Required when audio output is requested with modalities: [audio] */
// @DataContract
type AiChatAudio struct {
    /** @description Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16. */
    // @DataMember(Name="format")
    format string `json:"format"`
    /** @description The voice the model uses to respond. Supported voices are alloy, ash, ballad, coral, echo, fable, nova, onyx, sage, and shimmer. */
    // @DataMember(Name="voice")
    voice string `json:"voice"`
}

type ResponseFormat string

const (
    ResponseFormatText ResponseFormat = "text"
    ResponseFormatJsonObject = "json_object"
)

// @DataContract
type AiResponseFormat struct {
    /** @description An object specifying the format that the model must output. Compatible with GPT-4 Turbo and all GPT-3.5 Turbo models newer than gpt-3.5-turbo-1106. */
    // @DataMember(Name="response_format")
    response_format ResponseFormat `json:"response_format,omitempty"`
}

type ToolType string

const (
    ToolTypeFunction ToolType = "function"
)

// @DataContract
type Tool struct {
    /** @description The type of the tool. Currently, only function is supported. */
    // @DataMember(Name="type")
    type ToolType `json:"type,omitempty"`
}

type RoomType string

const (
    RoomTypeSingle RoomType = "Single"
    RoomTypeDouble = "Double"
    RoomTypeQueen = "Queen"
    RoomTypeTwin = "Twin"
    RoomTypeSuite = "Suite"
)

/** @description Discount Coupons */
type Coupon struct {
    id string `json:"id"`
    description string `json:"description"`
    discount int `json:"discount,omitempty"`
    expiryDate time.Time `json:"expiryDate,omitempty"`
}

type User struct {
    id string `json:"id"`
    userName string `json:"userName"`
    firstName *string `json:"firstName,omitempty"`
    lastName *string `json:"lastName,omitempty"`
    displayName *string `json:"displayName,omitempty"`
    profileUrl *string `json:"profileUrl,omitempty"`
}

/** @description Booking Details */
type Booking struct {
    AuditBase
    id int `json:"id,omitempty"`
    name string `json:"name"`
    roomType RoomType `json:"roomType,omitempty"`
    roomNumber int `json:"roomNumber,omitempty"`
    bookingStartDate time.Time `json:"bookingStartDate,omitempty"`
    bookingEndDate *time.Time `json:"bookingEndDate,omitempty"`
    cost float64 `json:"cost,omitempty"`
    // @References("typeof(MyApp.ServiceModel.Coupon)")
    couponId *string `json:"couponId,omitempty"`
    discount Coupon `json:"discount"`
    notes *string `json:"notes,omitempty"`
    cancelled *bool `json:"cancelled,omitempty"`
    employee User `json:"employee"`
}

type BackgroundJobRef struct {
    id int64 `json:"id,omitempty"`
    refId string `json:"refId"`
}

type PageStats struct {
    label string `json:"label"`
    total int `json:"total,omitempty"`
}

/** @description Annotations for the message, when applicable, as when using the web search tool. */
// @DataContract
type UrlCitation struct {
    /** @description The index of the last character of the URL citation in the message. */
    // @DataMember(Name="end_index")
    end_index int `json:"end_index,omitempty"`
    /** @description The index of the first character of the URL citation in the message. */
    // @DataMember(Name="start_index")
    start_index int `json:"start_index,omitempty"`
    /** @description The title of the web resource. */
    // @DataMember(Name="title")
    title string `json:"title"`
    /** @description The URL of the web resource. */
    // @DataMember(Name="url")
    url string `json:"url"`
}

/** @description Annotations for the message, when applicable, as when using the web search tool. */
// @DataContract
type ChoiceAnnotation struct {
    /** @description The type of the URL citation. Always url_citation. */
    // @DataMember(Name="type")
    type string `json:"type"`
    /** @description A URL citation when using web search. */
    // @DataMember(Name="url_citation")
    url_citation UrlCitation `json:"url_citation"`
}

/** @description If the audio output modality is requested, this object contains data about the audio response from the model. */
// @DataContract
type ChoiceAudio struct {
    /** @description Base64 encoded audio bytes generated by the model, in the format specified in the request. */
    // @DataMember(Name="data")
    data string `json:"data"`
    /** @description The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server for use in multi-turn conversations. */
    // @DataMember(Name="expires_at")
    expires_at int `json:"expires_at,omitempty"`
    /** @description Unique identifier for this audio response. */
    // @DataMember(Name="id")
    id string `json:"id"`
    /** @description Transcript of the audio generated by the model. */
    // @DataMember(Name="transcript")
    transcript string `json:"transcript"`
}

// @DataContract
type ChoiceMessage struct {
    /** @description The contents of the message. */
    // @DataMember(Name="content")
    content string `json:"content"`
    /** @description The refusal message generated by the model. */
    // @DataMember(Name="refusal")
    refusal *string `json:"refusal,omitempty"`
    /** @description The reasoning process used by the model. */
    // @DataMember(Name="reasoning")
    reasoning *string `json:"reasoning,omitempty"`
    /** @description The role of the author of this message. */
    // @DataMember(Name="role")
    role string `json:"role"`
    /** @description Annotations for the message, when applicable, as when using the web search tool. */
    // @DataMember(Name="annotations")
    annotations []ChoiceAnnotation `json:"annotations,omitempty"`
    /** @description If the audio output modality is requested, this object contains data about the audio response from the model. */
    // @DataMember(Name="audio")
    audio *ChoiceAudio `json:"audio,omitempty"`
    /** @description The tool calls generated by the model, such as function calls. */
    // @DataMember(Name="tool_calls")
    tool_calls []ToolCall `json:"tool_calls,omitempty"`
}

// @DataContract
type Choice struct {
    /** @description The reason the model stopped generating tokens. This will be stop if the model hit a natural stop point or a provided stop sequence, length if the maximum number of tokens specified in the request was reached, content_filter if content was omitted due to a flag from our content filters, tool_calls if the model called a tool */
    // @DataMember(Name="finish_reason")
    finish_reason string `json:"finish_reason"`
    /** @description The index of the choice in the list of choices. */
    // @DataMember(Name="index")
    index int `json:"index,omitempty"`
    /** @description A chat completion message generated by the model. */
    // @DataMember(Name="message")
    message ChoiceMessage `json:"message"`
}

/** @description Usage statistics for the completion request. */
// @DataContract
type AiCompletionUsage struct {
    /** @description When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion. */
    // @DataMember(Name="accepted_prediction_tokens")
    accepted_prediction_tokens int `json:"accepted_prediction_tokens,omitempty"`
    /** @description Audio input tokens generated by the model. */
    // @DataMember(Name="audio_tokens")
    audio_tokens int `json:"audio_tokens,omitempty"`
    /** @description Tokens generated by the model for reasoning. */
    // @DataMember(Name="reasoning_tokens")
    reasoning_tokens int `json:"reasoning_tokens,omitempty"`
    /** @description When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion. */
    // @DataMember(Name="rejected_prediction_tokens")
    rejected_prediction_tokens int `json:"rejected_prediction_tokens,omitempty"`
}

/** @description Breakdown of tokens used in the prompt. */
// @DataContract
type AiPromptUsage struct {
    /** @description When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion. */
    // @DataMember(Name="accepted_prediction_tokens")
    accepted_prediction_tokens int `json:"accepted_prediction_tokens,omitempty"`
    /** @description Audio input tokens present in the prompt. */
    // @DataMember(Name="audio_tokens")
    audio_tokens int `json:"audio_tokens,omitempty"`
    /** @description Cached tokens present in the prompt. */
    // @DataMember(Name="cached_tokens")
    cached_tokens int `json:"cached_tokens,omitempty"`
}

/** @description Usage statistics for the completion request. */
// @DataContract
type AiUsage struct {
    /** @description Number of tokens in the generated completion. */
    // @DataMember(Name="completion_tokens")
    completion_tokens int `json:"completion_tokens,omitempty"`
    /** @description Number of tokens in the prompt. */
    // @DataMember(Name="prompt_tokens")
    prompt_tokens int `json:"prompt_tokens,omitempty"`
    /** @description Total number of tokens used in the request (prompt + completion). */
    // @DataMember(Name="total_tokens")
    total_tokens int `json:"total_tokens,omitempty"`
    /** @description Breakdown of tokens used in a completion. */
    // @DataMember(Name="completion_tokens_details")
    completion_tokens_details *AiCompletionUsage `json:"completion_tokens_details,omitempty"`
    /** @description Breakdown of tokens used in the prompt. */
    // @DataMember(Name="prompt_tokens_details")
    prompt_tokens_details *AiPromptUsage `json:"prompt_tokens_details,omitempty"`
}

/** @description Text content part */
// @DataContract
type AiTextContent struct {
    AiContent
    /** @description The text content. */
    // @DataMember(Name="text")
    text string `json:"text"`
}

// @DataContract
type AiImageUrl struct {
    /** @description Either a URL of the image or the base64 encoded image data. */
    // @DataMember(Name="url")
    url string `json:"url"`
}

/** @description Image content part */
// @DataContract
type AiImageContent struct {
    AiContent
    /** @description The image for this content. */
    // @DataMember(Name="image_url")
    image_url AiImageUrl `json:"image_url"`
}

/** @description Audio content part */
// @DataContract
type AiInputAudio struct {
    /** @description URL or Base64 encoded audio data. */
    // @DataMember(Name="data")
    data string `json:"data"`
    /** @description The format of the encoded audio data. Currently supports 'wav' and 'mp3'. */
    // @DataMember(Name="format")
    format string `json:"format"`
}

/** @description Audio content part */
// @DataContract
type AiAudioContent struct {
    AiContent
    /** @description The audio input for this content. */
    // @DataMember(Name="input_audio")
    input_audio AiInputAudio `json:"input_audio"`
}

/** @description File content part */
// @DataContract
type AiFile struct {
    /** @description The URL or base64 encoded file data, used when passing the file to the model as a string. */
    // @DataMember(Name="file_data")
    file_data string `json:"file_data"`
    /** @description The name of the file, used when passing the file to the model as a string. */
    // @DataMember(Name="filename")
    filename string `json:"filename"`
    /** @description The ID of an uploaded file to use as input. */
    // @DataMember(Name="file_id")
    file_id *string `json:"file_id,omitempty"`
}

/** @description File content part */
// @DataContract
type AiFileContent struct {
    AiContent
    /** @description The file input for this content. */
    // @DataMember(Name="file")
    file AiFile `json:"file"`
}

type QueueCheckUrlsResponse struct {
    jobRef BackgroundJobRef `json:"jobRef"`
}

type HelloResponse struct {
    result string `json:"result"`
}

type AdminDataResponse struct {
    pageStats []PageStats `json:"pageStats"`
}

// @DataContract
type ChatResponse struct {
    /** @description A unique identifier for the chat completion. */
    // @DataMember(Name="id")
    id string `json:"id"`
    /** @description A list of chat completion choices. Can be more than one if n is greater than 1. */
    // @DataMember(Name="choices")
    choices []Choice `json:"choices"`
    /** @description The Unix timestamp (in seconds) of when the chat completion was created. */
    // @DataMember(Name="created")
    created int64 `json:"created,omitempty"`
    /** @description The model used for the chat completion. */
    // @DataMember(Name="model")
    model string `json:"model"`
    /** @description This fingerprint represents the backend configuration that the model runs with. */
    // @DataMember(Name="system_fingerprint")
    system_fingerprint *string `json:"system_fingerprint,omitempty"`
    /** @description The object type, which is always chat.completion. */
    // @DataMember(Name="object")
    object string `json:"object"`
    /** @description Specifies the processing type used for serving the request. */
    // @DataMember(Name="service_tier")
    service_tier *string `json:"service_tier,omitempty"`
    /** @description Usage statistics for the completion request. */
    // @DataMember(Name="usage")
    usage AiUsage `json:"usage"`
    /** @description Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. */
    // @DataMember(Name="metadata")
    metadata map[string]string `json:"metadata,omitempty"`
    // @DataMember(Name="responseStatus")
    responseStatus *ResponseStatus `json:"responseStatus,omitempty"`
}

type QueueCheckUrls struct {
    urls string `json:"urls"`
}

// @Route("/hello/{Name}")
type Hello struct {
    name *string `json:"name,omitempty"`
}

type AdminData struct {
}

/** @description Chat Completions API (OpenAI-Compatible) */
// @Route("/v1/chat/completions", "POST")
// @DataContract
type ChatCompletion struct {
    /** @description The messages to generate chat completions for. */
    // @DataMember(Name="messages")
    messages []AiMessage `json:"messages"`
    /** @description ID of the model to use. See the model endpoint compatibility table for details on which models work with the Chat API */
    // @DataMember(Name="model")
    model string `json:"model"`
    /** @description Parameters for audio output. Required when audio output is requested with modalities: [audio] */
    // @DataMember(Name="audio")
    audio *AiChatAudio `json:"audio,omitempty"`
    /** @description Modify the likelihood of specified tokens appearing in the completion. */
    // @DataMember(Name="logit_bias")
    logit_bias map[int]int `json:"logit_bias,omitempty"`
    /** @description Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. */
    // @DataMember(Name="metadata")
    metadata map[string]string `json:"metadata,omitempty"`
    /** @description Constrains effort on reasoning for reasoning models. Currently supported values are minimal, low, medium, and high (none, default). Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response. */
    // @DataMember(Name="reasoning_effort")
    reasoning_effort *string `json:"reasoning_effort,omitempty"`
    /** @description An object specifying the format that the model must output. Compatible with GPT-4 Turbo and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`. Setting Type to ResponseFormat.JsonObject enables JSON mode, which guarantees the message the model generates is valid JSON. */
    // @DataMember(Name="response_format")
    response_format *AiResponseFormat `json:"response_format,omitempty"`
    /** @description Specifies the processing type used for serving the request. */
    // @DataMember(Name="service_tier")
    service_tier *string `json:"service_tier,omitempty"`
    /** @description A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies. The IDs should be a string that uniquely identifies each user. */
    // @DataMember(Name="safety_identifier")
    safety_identifier *string `json:"safety_identifier,omitempty"`
    /** @description Up to 4 sequences where the API will stop generating further tokens. */
    // @DataMember(Name="stop")
    stop []string `json:"stop,omitempty"`
    /** @description Output types that you would like the model to generate. Most models are capable of generating text, which is the default: */
    // @DataMember(Name="modalities")
    modalities []string `json:"modalities,omitempty"`
    /** @description Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. */
    // @DataMember(Name="prompt_cache_key")
    prompt_cache_key *string `json:"prompt_cache_key,omitempty"`
    /** @description A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported. */
    // @DataMember(Name="tools")
    tools []Tool `json:"tools,omitempty"`
    /** @description Constrains the verbosity of the model's response. Lower values will result in more concise responses, while higher values will result in more verbose responses. Currently supported values are low, medium, and high. */
    // @DataMember(Name="verbosity")
    verbosity *string `json:"verbosity,omitempty"`
    /** @description What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. */
    // @DataMember(Name="temperature")
    temperature *float64 `json:"temperature,omitempty"`
    /** @description An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens. */
    // @DataMember(Name="max_completion_tokens")
    max_completion_tokens *int `json:"max_completion_tokens,omitempty"`
    /** @description An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used. */
    // @DataMember(Name="top_logprobs")
    top_logprobs *int `json:"top_logprobs,omitempty"`
    /** @description An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered. */
    // @DataMember(Name="top_p")
    top_p *float64 `json:"top_p,omitempty"`
    /** @description Number between `-2.0` and `2.0`. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. */
    // @DataMember(Name="frequency_penalty")
    frequency_penalty *float64 `json:"frequency_penalty,omitempty"`
    /** @description Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics. */
    // @DataMember(Name="presence_penalty")
    presence_penalty *float64 `json:"presence_penalty,omitempty"`
    /** @description This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result. Determinism is not guaranteed, and you should refer to the system_fingerprint response parameter to monitor changes in the backend. */
    // @DataMember(Name="seed")
    seed *int `json:"seed,omitempty"`
    /** @description How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs. */
    // @DataMember(Name="n")
    n *int `json:"n,omitempty"`
    /** @description Whether or not to store the output of this chat completion request for use in our model distillation or evals products. */
    // @DataMember(Name="store")
    store *bool `json:"store,omitempty"`
    /** @description Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message. */
    // @DataMember(Name="logprobs")
    logprobs *bool `json:"logprobs,omitempty"`
    /** @description Whether to enable parallel function calling during tool use. */
    // @DataMember(Name="parallel_tool_calls")
    parallel_tool_calls *bool `json:"parallel_tool_calls,omitempty"`
    /** @description Whether to enable thinking mode for some Qwen models and providers. */
    // @DataMember(Name="enable_thinking")
    enable_thinking *bool `json:"enable_thinking,omitempty"`
    /** @description If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a `data: [DONE]` message. */
    // @DataMember(Name="stream")
    stream *bool `json:"stream,omitempty"`
}

/** @description Find Bookings */
// @Route("/bookings", "GET")
// @Route("/bookings/{Id}", "GET")
type QueryBookings struct {
    QueryDb
    id *int `json:"id,omitempty"`
}

/** @description Find Coupons */
// @Route("/coupons", "GET")
type QueryCoupons struct {
    QueryDb
    id string `json:"id"`
}

// @ValidateRequest(Validator="IsAdmin")
type QueryUsers struct {
    QueryDb
    id *string `json:"id,omitempty"`
}

/** @description Create a new Booking */
// @Route("/bookings", "POST")
// @ValidateRequest(Validator="HasRole(`Employee`)")
type CreateBooking struct {
    /** @description Name this Booking is for */
    // @Validate(Validator="NotEmpty")
    name string `json:"name"`
    roomType RoomType `json:"roomType,omitempty"`
    // @Validate(Validator="GreaterThan(0)")
    roomNumber int `json:"roomNumber,omitempty"`
    // @Validate(Validator="GreaterThan(0)")
    cost float64 `json:"cost,omitempty"`
    // @Required()
    bookingStartDate time.Time `json:"bookingStartDate"`
    bookingEndDate *time.Time `json:"bookingEndDate,omitempty"`
    notes *string `json:"notes,omitempty"`
    couponId *string `json:"couponId,omitempty"`
}

/** @description Update an existing Booking */
// @Route("/booking/{Id}", "PATCH")
// @ValidateRequest(Validator="HasRole(`Employee`)")
type UpdateBooking struct {
    id int `json:"id,omitempty"`
    name *string `json:"name,omitempty"`
    roomType *RoomType `json:"roomType,omitempty"`
    // @Validate(Validator="GreaterThan(0)")
    roomNumber *int `json:"roomNumber,omitempty"`
    // @Validate(Validator="GreaterThan(0)")
    cost *float64 `json:"cost,omitempty"`
    bookingStartDate *time.Time `json:"bookingStartDate,omitempty"`
    bookingEndDate *time.Time `json:"bookingEndDate,omitempty"`
    notes *string `json:"notes,omitempty"`
    couponId *string `json:"couponId,omitempty"`
    cancelled *bool `json:"cancelled,omitempty"`
}

/** @description Delete a Booking */
// @Route("/booking/{Id}", "DELETE")
// @ValidateRequest(Validator="HasRole(`Manager`)")
type DeleteBooking struct {
    id int `json:"id,omitempty"`
}

// @Route("/coupons", "POST")
// @ValidateRequest(Validator="HasRole(`Employee`)")
type CreateCoupon struct {
    // @Validate(Validator="NotEmpty")
    id string `json:"id"`
    // @Validate(Validator="NotEmpty")
    description string `json:"description"`
    // @Validate(Validator="GreaterThan(0)")
    discount int `json:"discount,omitempty"`
    // @Validate(Validator="NotNull")
    expiryDate time.Time `json:"expiryDate"`
}

// @Route("/coupons/{Id}", "PATCH")
// @ValidateRequest(Validator="HasRole(`Employee`)")
type UpdateCoupon struct {
    id string `json:"id"`
    // @Validate(Validator="NotEmpty")
    description string `json:"description"`
    // @Validate(Validator="NotNull")
    // @Validate(Validator="GreaterThan(0)")
    discount *int `json:"discount"`
    // @Validate(Validator="NotNull")
    expiryDate *time.Time `json:"expiryDate"`
}

/** @description Delete a Coupon */
// @Route("/coupons/{Id}", "DELETE")
// @ValidateRequest(Validator="HasRole(`Manager`)")
type DeleteCoupon struct {
    id string `json:"id"`
}
