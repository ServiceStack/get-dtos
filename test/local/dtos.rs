/* Options:
Date: 2025-11-02 18:59:15
Version: 8.91
Tip: To override a DTO option, remove "//" prefix before updating
BaseUrl: https://localhost:5001

//GlobalNamespace: 
//MakePropertiesOptional: False
//AddServiceStackTypes: True
//AddResponseStatus: False
//AddImplicitVersion: 
//AddDescriptionAsComments: True
//IncludeTypes: 
//ExcludeTypes: 
//DefaultImports: serde::{Serialize, Deserialize},std::collections::HashMap
*/

use serde::{Serialize, Deserialize};
use std::collections::HashMap;


// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiContent {
    /// The type of the content part.
    // DataMember(Name="type")
    #[serde(rename = "type")]
    pub type: String,
}

/// The tool calls generated by the model, such as function calls.
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ToolCall {
    /// The ID of the tool call.
    // DataMember(Name="id")
    #[serde(rename = "id")]
    pub id: String,
    /// The type of the tool. Currently, only `function` is supported.
    // DataMember(Name="type")
    #[serde(rename = "type")]
    pub type: String,
    /// The function that the model called.
    // DataMember(Name="function")
    #[serde(rename = "function")]
    pub function: String,
}

/// A list of messages comprising the conversation so far.
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiMessage {
    /// The contents of the message.
    // DataMember(Name="content")
    #[serde(rename = "content")]
    pub content: Option<Vec<AiContent>>,
    /// The role of the author of this message. Valid values are `system`, `user`, `assistant` and `tool`.
    // DataMember(Name="role")
    #[serde(rename = "role")]
    pub role: String,
    /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    // DataMember(Name="name")
    #[serde(rename = "name")]
    pub name: Option<String>,
    /// The tool calls generated by the model, such as function calls.
    // DataMember(Name="tool_calls")
    #[serde(rename = "tool_calls")]
    pub tool_calls: Option<Vec<ToolCall>>,
    /// Tool call that this message is responding to.
    // DataMember(Name="tool_call_id")
    #[serde(rename = "tool_call_id")]
    pub tool_call_id: Option<String>,
}

/// Parameters for audio output. Required when audio output is requested with modalities: [audio]
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiChatAudio {
    /// Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
    // DataMember(Name="format")
    #[serde(rename = "format")]
    pub format: String,
    /// The voice the model uses to respond. Supported voices are alloy, ash, ballad, coral, echo, fable, nova, onyx, sage, and shimmer.
    // DataMember(Name="voice")
    #[serde(rename = "voice")]
    pub voice: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum ResponseFormat {
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "json_object")]
    JsonObject,
}

// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiResponseFormat {
    /// An object specifying the format that the model must output. Compatible with GPT-4 Turbo and all GPT-3.5 Turbo models newer than gpt-3.5-turbo-1106.
    // DataMember(Name="response_format")
    #[serde(rename = "response_format")]
    pub response_format: ResponseFormat,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum ToolType {
    #[serde(rename = "function")]
    Function,
}

// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct Tool {
    /// The type of the tool. Currently, only function is supported.
    // DataMember(Name="type")
    #[serde(rename = "type")]
    pub type: ToolType,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum RoomType {
    #[serde(rename = "Single")]
    Single,
    #[serde(rename = "Double")]
    Double,
    #[serde(rename = "Queen")]
    Queen,
    #[serde(rename = "Twin")]
    Twin,
    #[serde(rename = "Suite")]
    Suite,
}

/// Discount Coupons
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct Coupon {
    pub id: String,
    pub description: String,
    pub discount: i32,
    pub expiryDate: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct User {
    pub id: String,
    pub userName: String,
    pub firstName: Option<String>,
    pub lastName: Option<String>,
    pub displayName: Option<String>,
    pub profileUrl: Option<String>,
}

/// Booking Details
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct Booking {
    pub id: i32,
    pub name: String,
    pub roomType: RoomType,
    pub roomNumber: i32,
    pub bookingStartDate: String,
    pub bookingEndDate: Option<String>,
    pub cost: f64,
    // References(typeof(Coupon))
    pub couponId: Option<String>,
    pub discount: Coupon,
    pub notes: Option<String>,
    pub cancelled: Option<bool>,
    pub employee: User,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct BackgroundJobRef {
    pub id: i64,
    pub refId: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct PageStats {
    pub label: String,
    pub total: i32,
}

/// Annotations for the message, when applicable, as when using the web search tool.
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct UrlCitation {
    /// The index of the last character of the URL citation in the message.
    // DataMember(Name="end_index")
    #[serde(rename = "end_index")]
    pub end_index: i32,
    /// The index of the first character of the URL citation in the message.
    // DataMember(Name="start_index")
    #[serde(rename = "start_index")]
    pub start_index: i32,
    /// The title of the web resource.
    // DataMember(Name="title")
    #[serde(rename = "title")]
    pub title: String,
    /// The URL of the web resource.
    // DataMember(Name="url")
    #[serde(rename = "url")]
    pub url: String,
}

/// Annotations for the message, when applicable, as when using the web search tool.
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ChoiceAnnotation {
    /// The type of the URL citation. Always url_citation.
    // DataMember(Name="type")
    #[serde(rename = "type")]
    pub type: String,
    /// A URL citation when using web search.
    // DataMember(Name="url_citation")
    #[serde(rename = "url_citation")]
    pub url_citation: UrlCitation,
}

/// If the audio output modality is requested, this object contains data about the audio response from the model.
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ChoiceAudio {
    /// Base64 encoded audio bytes generated by the model, in the format specified in the request.
    // DataMember(Name="data")
    #[serde(rename = "data")]
    pub data: String,
    /// The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server for use in multi-turn conversations.
    // DataMember(Name="expires_at")
    #[serde(rename = "expires_at")]
    pub expires_at: i32,
    /// Unique identifier for this audio response.
    // DataMember(Name="id")
    #[serde(rename = "id")]
    pub id: String,
    /// Transcript of the audio generated by the model.
    // DataMember(Name="transcript")
    #[serde(rename = "transcript")]
    pub transcript: String,
}

// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ChoiceMessage {
    /// The contents of the message.
    // DataMember(Name="content")
    #[serde(rename = "content")]
    pub content: String,
    /// The refusal message generated by the model.
    // DataMember(Name="refusal")
    #[serde(rename = "refusal")]
    pub refusal: Option<String>,
    /// The reasoning process used by the model.
    // DataMember(Name="reasoning")
    #[serde(rename = "reasoning")]
    pub reasoning: Option<String>,
    /// The role of the author of this message.
    // DataMember(Name="role")
    #[serde(rename = "role")]
    pub role: String,
    /// Annotations for the message, when applicable, as when using the web search tool.
    // DataMember(Name="annotations")
    #[serde(rename = "annotations")]
    pub annotations: Option<Vec<ChoiceAnnotation>>,
    /// If the audio output modality is requested, this object contains data about the audio response from the model.
    // DataMember(Name="audio")
    #[serde(rename = "audio")]
    pub audio: Option<ChoiceAudio>,
    /// The tool calls generated by the model, such as function calls.
    // DataMember(Name="tool_calls")
    #[serde(rename = "tool_calls")]
    pub tool_calls: Option<Vec<ToolCall>>,
}

// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct Choice {
    /// The reason the model stopped generating tokens. This will be stop if the model hit a natural stop point or a provided stop sequence, length if the maximum number of tokens specified in the request was reached, content_filter if content was omitted due to a flag from our content filters, tool_calls if the model called a tool
    // DataMember(Name="finish_reason")
    #[serde(rename = "finish_reason")]
    pub finish_reason: String,
    /// The index of the choice in the list of choices.
    // DataMember(Name="index")
    #[serde(rename = "index")]
    pub index: i32,
    /// A chat completion message generated by the model.
    // DataMember(Name="message")
    #[serde(rename = "message")]
    pub message: ChoiceMessage,
}

/// Usage statistics for the completion request.
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiCompletionUsage {
    /// When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion.
    // DataMember(Name="accepted_prediction_tokens")
    #[serde(rename = "accepted_prediction_tokens")]
    pub accepted_prediction_tokens: i32,
    /// Audio input tokens generated by the model.
    // DataMember(Name="audio_tokens")
    #[serde(rename = "audio_tokens")]
    pub audio_tokens: i32,
    /// Tokens generated by the model for reasoning.
    // DataMember(Name="reasoning_tokens")
    #[serde(rename = "reasoning_tokens")]
    pub reasoning_tokens: i32,
    /// When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion.
    // DataMember(Name="rejected_prediction_tokens")
    #[serde(rename = "rejected_prediction_tokens")]
    pub rejected_prediction_tokens: i32,
}

/// Breakdown of tokens used in the prompt.
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiPromptUsage {
    /// When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion.
    // DataMember(Name="accepted_prediction_tokens")
    #[serde(rename = "accepted_prediction_tokens")]
    pub accepted_prediction_tokens: i32,
    /// Audio input tokens present in the prompt.
    // DataMember(Name="audio_tokens")
    #[serde(rename = "audio_tokens")]
    pub audio_tokens: i32,
    /// Cached tokens present in the prompt.
    // DataMember(Name="cached_tokens")
    #[serde(rename = "cached_tokens")]
    pub cached_tokens: i32,
}

/// Usage statistics for the completion request.
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiUsage {
    /// Number of tokens in the generated completion.
    // DataMember(Name="completion_tokens")
    #[serde(rename = "completion_tokens")]
    pub completion_tokens: i32,
    /// Number of tokens in the prompt.
    // DataMember(Name="prompt_tokens")
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i32,
    /// Total number of tokens used in the request (prompt + completion).
    // DataMember(Name="total_tokens")
    #[serde(rename = "total_tokens")]
    pub total_tokens: i32,
    /// Breakdown of tokens used in a completion.
    // DataMember(Name="completion_tokens_details")
    #[serde(rename = "completion_tokens_details")]
    pub completion_tokens_details: Option<AiCompletionUsage>,
    /// Breakdown of tokens used in the prompt.
    // DataMember(Name="prompt_tokens_details")
    #[serde(rename = "prompt_tokens_details")]
    pub prompt_tokens_details: Option<AiPromptUsage>,
}

/// Text content part
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiTextContent {
    /// The text content.
    // DataMember(Name="text")
    #[serde(rename = "text")]
    pub text: String,
}

// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiImageUrl {
    /// Either a URL of the image or the base64 encoded image data.
    // DataMember(Name="url")
    #[serde(rename = "url")]
    pub url: String,
}

/// Image content part
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiImageContent {
    /// The image for this content.
    // DataMember(Name="image_url")
    #[serde(rename = "image_url")]
    pub image_url: AiImageUrl,
}

/// Audio content part
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiInputAudio {
    /// URL or Base64 encoded audio data.
    // DataMember(Name="data")
    #[serde(rename = "data")]
    pub data: String,
    /// The format of the encoded audio data. Currently supports 'wav' and 'mp3'.
    // DataMember(Name="format")
    #[serde(rename = "format")]
    pub format: String,
}

/// Audio content part
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiAudioContent {
    /// The audio input for this content.
    // DataMember(Name="input_audio")
    #[serde(rename = "input_audio")]
    pub input_audio: AiInputAudio,
}

/// File content part
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiFile {
    /// The URL or base64 encoded file data, used when passing the file to the model as a string.
    // DataMember(Name="file_data")
    #[serde(rename = "file_data")]
    pub file_data: String,
    /// The name of the file, used when passing the file to the model as a string.
    // DataMember(Name="filename")
    #[serde(rename = "filename")]
    pub filename: String,
    /// The ID of an uploaded file to use as input.
    // DataMember(Name="file_id")
    #[serde(rename = "file_id")]
    pub file_id: Option<String>,
}

/// File content part
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AiFileContent {
    /// The file input for this content.
    // DataMember(Name="file")
    #[serde(rename = "file")]
    pub file: AiFile,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct QueueCheckUrlsResponse {
    pub jobRef: BackgroundJobRef,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct HelloResponse {
    pub result: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AdminDataResponse {
    pub pageStats: Vec<PageStats>,
}

// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ChatResponse {
    /// A unique identifier for the chat completion.
    // DataMember(Name="id")
    #[serde(rename = "id")]
    pub id: String,
    /// A list of chat completion choices. Can be more than one if n is greater than 1.
    // DataMember(Name="choices")
    #[serde(rename = "choices")]
    pub choices: Vec<Choice>,
    /// The Unix timestamp (in seconds) of when the chat completion was created.
    // DataMember(Name="created")
    #[serde(rename = "created")]
    pub created: i64,
    /// The model used for the chat completion.
    // DataMember(Name="model")
    #[serde(rename = "model")]
    pub model: String,
    /// This fingerprint represents the backend configuration that the model runs with.
    // DataMember(Name="system_fingerprint")
    #[serde(rename = "system_fingerprint")]
    pub system_fingerprint: Option<String>,
    /// The object type, which is always chat.completion.
    // DataMember(Name="object")
    #[serde(rename = "object")]
    pub object: String,
    /// Specifies the processing type used for serving the request.
    // DataMember(Name="service_tier")
    #[serde(rename = "service_tier")]
    pub service_tier: Option<String>,
    /// Usage statistics for the completion request.
    // DataMember(Name="usage")
    #[serde(rename = "usage")]
    pub usage: AiUsage,
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format.
    // DataMember(Name="metadata")
    #[serde(rename = "metadata")]
    pub metadata: Option<HashMap<String, String>>,
    // DataMember(Name="responseStatus")
    #[serde(rename = "responseStatus")]
    pub responseStatus: Option<ResponseStatus>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct QueueCheckUrls {
    pub urls: String,
}

// Route("/hello/{Name}")
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct Hello {
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AdminData {
}

/// Chat Completions API (OpenAI-Compatible)
// Route("/v1/chat/completions", "POST")
// DataContract
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ChatCompletion {
    /// The messages to generate chat completions for.
    // DataMember(Name="messages")
    #[serde(rename = "messages")]
    pub messages: Vec<AiMessage>,
    /// ID of the model to use. See the model endpoint compatibility table for details on which models work with the Chat API
    // DataMember(Name="model")
    #[serde(rename = "model")]
    pub model: String,
    /// Parameters for audio output. Required when audio output is requested with modalities: [audio]
    // DataMember(Name="audio")
    #[serde(rename = "audio")]
    pub audio: Option<AiChatAudio>,
    /// Modify the likelihood of specified tokens appearing in the completion.
    // DataMember(Name="logit_bias")
    #[serde(rename = "logit_bias")]
    pub logit_bias: Option<HashMap<i32, i32>>,
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format.
    // DataMember(Name="metadata")
    #[serde(rename = "metadata")]
    pub metadata: Option<HashMap<String, String>>,
    /// Constrains effort on reasoning for reasoning models. Currently supported values are minimal, low, medium, and high (none, default). Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
    // DataMember(Name="reasoning_effort")
    #[serde(rename = "reasoning_effort")]
    pub reasoning_effort: Option<String>,
    /// An object specifying the format that the model must output. Compatible with GPT-4 Turbo and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`. Setting Type to ResponseFormat.JsonObject enables JSON mode, which guarantees the message the model generates is valid JSON.
    // DataMember(Name="response_format")
    #[serde(rename = "response_format")]
    pub response_format: Option<AiResponseFormat>,
    /// Specifies the processing type used for serving the request.
    // DataMember(Name="service_tier")
    #[serde(rename = "service_tier")]
    pub service_tier: Option<String>,
    /// A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies. The IDs should be a string that uniquely identifies each user.
    // DataMember(Name="safety_identifier")
    #[serde(rename = "safety_identifier")]
    pub safety_identifier: Option<String>,
    /// Up to 4 sequences where the API will stop generating further tokens.
    // DataMember(Name="stop")
    #[serde(rename = "stop")]
    pub stop: Option<Vec<String>>,
    /// Output types that you would like the model to generate. Most models are capable of generating text, which is the default:
    // DataMember(Name="modalities")
    #[serde(rename = "modalities")]
    pub modalities: Option<Vec<String>>,
    /// Used by OpenAI to cache responses for similar requests to optimize your cache hit rates.
    // DataMember(Name="prompt_cache_key")
    #[serde(rename = "prompt_cache_key")]
    pub prompt_cache_key: Option<String>,
    /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.
    // DataMember(Name="tools")
    #[serde(rename = "tools")]
    pub tools: Option<Vec<Tool>>,
    /// Constrains the verbosity of the model's response. Lower values will result in more concise responses, while higher values will result in more verbose responses. Currently supported values are low, medium, and high.
    // DataMember(Name="verbosity")
    #[serde(rename = "verbosity")]
    pub verbosity: Option<String>,
    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
    // DataMember(Name="temperature")
    #[serde(rename = "temperature")]
    pub temperature: Option<f64>,
    /// An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens.
    // DataMember(Name="max_completion_tokens")
    #[serde(rename = "max_completion_tokens")]
    pub max_completion_tokens: Option<i32>,
    /// An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
    // DataMember(Name="top_logprobs")
    #[serde(rename = "top_logprobs")]
    pub top_logprobs: Option<i32>,
    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
    // DataMember(Name="top_p")
    #[serde(rename = "top_p")]
    pub top_p: Option<f64>,
    /// Number between `-2.0` and `2.0`. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
    // DataMember(Name="frequency_penalty")
    #[serde(rename = "frequency_penalty")]
    pub frequency_penalty: Option<f64>,
    /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
    // DataMember(Name="presence_penalty")
    #[serde(rename = "presence_penalty")]
    pub presence_penalty: Option<f64>,
    /// This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result. Determinism is not guaranteed, and you should refer to the system_fingerprint response parameter to monitor changes in the backend.
    // DataMember(Name="seed")
    #[serde(rename = "seed")]
    pub seed: Option<i32>,
    /// How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
    // DataMember(Name="n")
    #[serde(rename = "n")]
    pub n: Option<i32>,
    /// Whether or not to store the output of this chat completion request for use in our model distillation or evals products.
    // DataMember(Name="store")
    #[serde(rename = "store")]
    pub store: Option<bool>,
    /// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
    // DataMember(Name="logprobs")
    #[serde(rename = "logprobs")]
    pub logprobs: Option<bool>,
    /// Whether to enable parallel function calling during tool use.
    // DataMember(Name="parallel_tool_calls")
    #[serde(rename = "parallel_tool_calls")]
    pub parallel_tool_calls: Option<bool>,
    /// Whether to enable thinking mode for some Qwen models and providers.
    // DataMember(Name="enable_thinking")
    #[serde(rename = "enable_thinking")]
    pub enable_thinking: Option<bool>,
    /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a `data: [DONE]` message.
    // DataMember(Name="stream")
    #[serde(rename = "stream")]
    pub stream: Option<bool>,
}

/// Find Bookings
// Route("/bookings", "GET")
// Route("/bookings/{Id}", "GET")
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct QueryBookings {
    pub id: Option<i32>,
}

/// Find Coupons
// Route("/coupons", "GET")
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct QueryCoupons {
    pub id: String,
}

// ValidateRequest(Validator="IsAdmin")
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct QueryUsers {
    pub id: Option<String>,
}

/// Create a new Booking
// Route("/bookings", "POST")
// ValidateRequest(Validator="HasRole(`Employee`)")
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct CreateBooking {
    /// Name this Booking is for
    // Validate(Validator="NotEmpty")
    pub name: String,
    pub roomType: RoomType,
    // Validate(Validator="GreaterThan(0)")
    pub roomNumber: i32,
    // Validate(Validator="GreaterThan(0)")
    pub cost: f64,
    // Required
    pub bookingStartDate: String,
    pub bookingEndDate: Option<String>,
    pub notes: Option<String>,
    pub couponId: Option<String>,
}

/// Update an existing Booking
// Route("/booking/{Id}", "PATCH")
// ValidateRequest(Validator="HasRole(`Employee`)")
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct UpdateBooking {
    pub id: i32,
    pub name: Option<String>,
    pub roomType: Option<RoomType>,
    // Validate(Validator="GreaterThan(0)")
    pub roomNumber: Option<i32>,
    // Validate(Validator="GreaterThan(0)")
    pub cost: Option<f64>,
    pub bookingStartDate: Option<String>,
    pub bookingEndDate: Option<String>,
    pub notes: Option<String>,
    pub couponId: Option<String>,
    pub cancelled: Option<bool>,
}

/// Delete a Booking
// Route("/booking/{Id}", "DELETE")
// ValidateRequest(Validator="HasRole(`Manager`)")
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct DeleteBooking {
    pub id: i32,
}

// Route("/coupons", "POST")
// ValidateRequest(Validator="HasRole(`Employee`)")
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct CreateCoupon {
    // Validate(Validator="NotEmpty")
    pub id: String,
    // Validate(Validator="NotEmpty")
    pub description: String,
    // Validate(Validator="GreaterThan(0)")
    pub discount: i32,
    // Validate(Validator="NotNull")
    pub expiryDate: String,
}

// Route("/coupons/{Id}", "PATCH")
// ValidateRequest(Validator="HasRole(`Employee`)")
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct UpdateCoupon {
    pub id: String,
    // Validate(Validator="NotEmpty")
    pub description: String,
    // Validate(Validator="NotNull")
    // Validate(Validator="GreaterThan(0)")
    pub discount: Option<i32>,
    // Validate(Validator="NotNull")
    pub expiryDate: Option<String>,
}

/// Delete a Coupon
// Route("/coupons/{Id}", "DELETE")
// ValidateRequest(Validator="HasRole(`Manager`)")
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct DeleteCoupon {
    pub id: String,
}
